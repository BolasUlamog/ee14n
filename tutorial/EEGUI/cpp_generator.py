"""
C++ Code Generator for Arduino Laser Projector
Generates complete .cpp file with embedded angle data
"""

from typing import List
from pathlib import Path


CPP_TEMPLATE = '''// Dual Stepper Motor X-Y Angle Control
// SMOOTH SPLINE DATA PLAYER
// Generated by EEGUI Laser Projector Tool

#include <AccelStepper.h>

// --- LASER SETUP ---
#define LASER_PIN 7

// --- PINS ---
#define X_STEP_PIN 2
#define X_DIR_PIN 3
#define Y_STEP_PIN 4
#define Y_DIR_PIN 5

// --- MOTOR SETTINGS ---
#define STEPS_PER_REV 200  
#define MICROSTEPS 0.25    

AccelStepper stepperX(AccelStepper::DRIVER, X_STEP_PIN, X_DIR_PIN);
AccelStepper stepperY(AccelStepper::DRIVER, Y_STEP_PIN, Y_DIR_PIN);

// --- GENERATED DATA ({point_count} points) ---
// Wall Distance: {wall_distance}m | Projection Size: {projection_size}m

const float xAngles[] = {x_angles};
const float yAngles[] = {y_angles};
const bool laserValues[] = {laser_values};

// --- VARIABLES ---
int numAngles = sizeof(xAngles) / sizeof(xAngles[0]);
int currentIndex = 0;

void setup() {{
  Serial.begin(9600);
  pinMode(LASER_PIN, OUTPUT);
  digitalWrite(LASER_PIN, LOW); 
  
  // --- SPEED SETTINGS ---
  stepperX.setMaxSpeed(100);       
  stepperX.setAcceleration(50);   
  stepperX.setCurrentPosition(40); 
  
  stepperY.setMaxSpeed(100);       
  stepperY.setAcceleration(50);   
  stepperY.setCurrentPosition(40); 
  
  Serial.println("System Ready.");
  Serial.print("Points loaded: ");
  Serial.println(numAngles);
  delay(1000);
}}

void loop() {{
  stepperX.run();
  stepperY.run();

  if (stepperX.distanceToGo() == 0 && stepperY.distanceToGo() == 0) {{
      
      // Sequence complete check
      if (currentIndex >= numAngles) {{
          currentIndex = 0;
          digitalWrite(LASER_PIN, LOW);
          delay(2000);
      }}
      
      if (currentIndex < numAngles) {{
          
          // 1. SET LASER
          if (laserValues[currentIndex]) {{
             digitalWrite(LASER_PIN, HIGH);
          }} else {{
             digitalWrite(LASER_PIN, LOW);
          }}
          
          // 2. MOVE MOTORS
          moveToAngles(xAngles[currentIndex], yAngles[currentIndex]);
          
          // 3. INCREMENT
          currentIndex++;
          
          // 4. WAIT
          delay(5); 
      }}
  }}
}}

void moveToAngles(float targetXData, float targetYData) {{
  // SWAPPED LOGIC (X Data -> Y Stepper)
  // Uses Absolute Positioning
  
  long stepsForStepperX = angleToAbsoluteSteps(targetYData);
  stepperX.moveTo(stepsForStepperX);

  long stepsForStepperY = angleToAbsoluteSteps(targetXData);
  stepperY.moveTo(stepsForStepperY);
}}

long angleToAbsoluteSteps(float angle) {{
  float stepsPerDegree = (STEPS_PER_REV * MICROSTEPS) / 360.0;
  return (long)(angle * stepsPerDegree);
}}
'''


def format_float_array(values: List[float]) -> str:
    """Format list of floats as C++ array initializer"""
    return "{" + ", ".join(str(v) for v in values) + "}"


def format_bool_array(values: List[bool]) -> str:
    """Format list of bools as C++ array initializer"""
    return "{" + ", ".join("true" if v else "false" for v in values) + "}"


def generate_cpp(
    x_angles: List[float],
    y_angles: List[float],
    laser_states: List[bool],
    wall_distance: float,
    projection_size: float
) -> str:
    """Generate complete C++ code with embedded data"""
    
    return CPP_TEMPLATE.format(
        point_count=len(x_angles),
        wall_distance=wall_distance,
        projection_size=projection_size,
        x_angles=format_float_array(x_angles),
        y_angles=format_float_array(y_angles),
        laser_values=format_bool_array(laser_states)
    )


def save_cpp_file(
    output_path: str,
    x_angles: List[float],
    y_angles: List[float],
    laser_states: List[bool],
    wall_distance: float,
    projection_size: float
) -> str:
    """Generate and save C++ file, returns the path"""
    
    cpp_code = generate_cpp(
        x_angles, y_angles, laser_states,
        wall_distance, projection_size
    )
    
    path = Path(output_path)
    path.write_text(cpp_code)
    
    return str(path.absolute())

